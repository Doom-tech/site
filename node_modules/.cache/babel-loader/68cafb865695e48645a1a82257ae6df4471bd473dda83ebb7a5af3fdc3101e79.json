{"ast":null,"code":"var _jsxFileName = \"D:\\\\visitka\\\\src\\\\components\\\\MatrixRain.tsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect } from 'react';\nimport styled from 'styled-components';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst MatrixCanvas = styled.canvas`\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 1;\n`;\n\n// Символы для матричного дождя\n_c = MatrixCanvas;\nconst MATRIX_CHARACTERS = ['ﾊ', 'ﾐ', 'ﾋ', 'ｰ', 'ｳ', 'ｼ', 'ﾅ', 'ﾓ', 'ﾆ', 'ｻ', 'ﾜ', 'ﾂ', 'ｵ', 'ﾘ', 'ｱ', 'ﾎ', 'ﾃ', 'ﾏ', 'ｹ', 'ﾒ', 'ｴ', 'ｶ', 'ｷ', 'ﾑ', 'ﾕ', 'ﾗ', 'ｾ', 'ﾈ', 'ｽ', 'ﾀ', 'ﾇ', 'ﾍ', 'ｦ', 'ｲ', 'ｸ', 'ｺ', 'ｿ', 'ﾁ', 'ﾄ', 'ﾉ', 'ﾌ', 'ﾐ', 'ﾖ', 'ﾙ', 'ﾚ', 'ﾛ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\nconst MatrixRain = ({\n  opacity = 0.8\n}) => {\n  _s();\n  const canvasRef = useRef(null);\n\n  // Получение случайного символа из набора\n  const getRandomChar = () => {\n    return MATRIX_CHARACTERS[Math.floor(Math.random() * MATRIX_CHARACTERS.length)];\n  };\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Устанавливаем размеры canvas равными размерам окна\n    const resizeCanvas = () => {\n      if (canvas) {\n        canvas.width = canvas.clientWidth;\n        canvas.height = canvas.clientHeight;\n      }\n    };\n\n    // Вызываем функцию при монтировании и при изменении размера окна\n    resizeCanvas();\n    window.addEventListener('resize', resizeCanvas);\n    const fontSize = 14;\n    const columns = Math.floor(canvas.width / fontSize);\n\n    // Массив для хранения позиций Y для каждой колонки\n    const drops = [];\n    for (let i = 0; i < columns; i++) {\n      // Начальная позиция для каждой колонки - случайное положение вне экрана\n      drops[i] = Math.floor(Math.random() * -canvas.height / fontSize);\n    }\n\n    // Функция отрисовки матричного дождя\n    const draw = () => {\n      // Прозрачный черный цвет создает эффект затухания\n      ctx.fillStyle = `rgba(0, 0, 0, 0.05)`;\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n      // Устанавливаем цвет и шрифт для символов\n      ctx.fillStyle = '#0F0';\n      ctx.font = `${fontSize}px monospace`;\n\n      // Отрисовка символов\n      for (let i = 0; i < drops.length; i++) {\n        // Случайный символ для текущей позиции\n        const text = getRandomChar();\n\n        // Отрисовка символа\n        const x = i * fontSize;\n        const y = drops[i] * fontSize;\n\n        // Первый символ в колонке делаем светлее для эффекта \"головы\" дождя\n        if (drops[i] >= 0) {\n          ctx.fillStyle = '#FFF'; // Белый цвет для \"головы\"\n          ctx.fillText(text, x, y);\n          ctx.fillStyle = '#0F0'; // Возвращаем зеленый для остальных символов\n        }\n\n        // Смещаем символ вниз на следующей итерации\n        drops[i]++;\n\n        // Если символ вышел за пределы экрана, создаем новую \"каплю\" с вероятностью\n        if (y > canvas.height && Math.random() > 0.975) {\n          drops[i] = Math.floor(Math.random() * -10); // Начинаем новую \"каплю\" над экраном\n        }\n      }\n    };\n\n    // Запускаем анимацию\n    const intervalId = setInterval(draw, 33); // ~30 fps\n\n    // Очистка при размонтировании компонента\n    return () => {\n      clearInterval(intervalId);\n      window.removeEventListener('resize', resizeCanvas);\n    };\n  }, []);\n  return /*#__PURE__*/_jsxDEV(MatrixCanvas, {\n    ref: canvasRef,\n    style: {\n      opacity\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 113,\n    columnNumber: 10\n  }, this);\n};\n_s(MatrixRain, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c2 = MatrixRain;\nexport default MatrixRain;\nvar _c, _c2;\n$RefreshReg$(_c, \"MatrixCanvas\");\n$RefreshReg$(_c2, \"MatrixRain\");","map":{"version":3,"names":["React","useRef","useEffect","styled","jsxDEV","_jsxDEV","MatrixCanvas","canvas","_c","MATRIX_CHARACTERS","MatrixRain","opacity","_s","canvasRef","getRandomChar","Math","floor","random","length","current","ctx","getContext","resizeCanvas","width","clientWidth","height","clientHeight","window","addEventListener","fontSize","columns","drops","i","draw","fillStyle","fillRect","font","text","x","y","fillText","intervalId","setInterval","clearInterval","removeEventListener","ref","style","fileName","_jsxFileName","lineNumber","columnNumber","_c2","$RefreshReg$"],"sources":["D:/visitka/src/components/MatrixRain.tsx"],"sourcesContent":["import React, { useRef, useEffect } from 'react';\r\nimport styled from 'styled-components';\r\n\r\nconst MatrixCanvas = styled.canvas`\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  z-index: 1;\r\n`;\r\n\r\n// Символы для матричного дождя\r\nconst MATRIX_CHARACTERS = [\r\n  'ﾊ', 'ﾐ', 'ﾋ', 'ｰ', 'ｳ', 'ｼ', 'ﾅ', 'ﾓ', 'ﾆ', 'ｻ',\r\n  'ﾜ', 'ﾂ', 'ｵ', 'ﾘ', 'ｱ', 'ﾎ', 'ﾃ', 'ﾏ', 'ｹ', 'ﾒ',\r\n  'ｴ', 'ｶ', 'ｷ', 'ﾑ', 'ﾕ', 'ﾗ', 'ｾ', 'ﾈ', 'ｽ', 'ﾀ',\r\n  'ﾇ', 'ﾍ', 'ｦ', 'ｲ', 'ｸ', 'ｺ', 'ｿ', 'ﾁ', 'ﾄ', 'ﾉ',\r\n  'ﾌ', 'ﾐ', 'ﾖ', 'ﾙ', 'ﾚ', 'ﾛ', '0', '1', '2', '3',\r\n  '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D',\r\n  'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\r\n  'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',\r\n  'Y', 'Z'\r\n];\r\n\r\ninterface MatrixRainProps {\r\n  opacity?: number;\r\n}\r\n\r\nconst MatrixRain: React.FC<MatrixRainProps> = ({ opacity = 0.8 }) => {\r\n  const canvasRef = useRef<HTMLCanvasElement>(null);\r\n  \r\n  // Получение случайного символа из набора\r\n  const getRandomChar = () => {\r\n    return MATRIX_CHARACTERS[Math.floor(Math.random() * MATRIX_CHARACTERS.length)];\r\n  };\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return;\r\n\r\n    const ctx = canvas.getContext('2d');\r\n    if (!ctx) return;\r\n\r\n    // Устанавливаем размеры canvas равными размерам окна\r\n    const resizeCanvas = () => {\r\n      if (canvas) {\r\n        canvas.width = canvas.clientWidth;\r\n        canvas.height = canvas.clientHeight;\r\n      }\r\n    };\r\n\r\n    // Вызываем функцию при монтировании и при изменении размера окна\r\n    resizeCanvas();\r\n    window.addEventListener('resize', resizeCanvas);\r\n\r\n    const fontSize = 14;\r\n    const columns = Math.floor(canvas.width / fontSize);\r\n    \r\n    // Массив для хранения позиций Y для каждой колонки\r\n    const drops: number[] = [];\r\n    for (let i = 0; i < columns; i++) {\r\n      // Начальная позиция для каждой колонки - случайное положение вне экрана\r\n      drops[i] = Math.floor(Math.random() * -canvas.height / fontSize);\r\n    }\r\n\r\n    // Функция отрисовки матричного дождя\r\n    const draw = () => {\r\n      // Прозрачный черный цвет создает эффект затухания\r\n      ctx.fillStyle = `rgba(0, 0, 0, 0.05)`;\r\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n      \r\n      // Устанавливаем цвет и шрифт для символов\r\n      ctx.fillStyle = '#0F0';\r\n      ctx.font = `${fontSize}px monospace`;\r\n      \r\n      // Отрисовка символов\r\n      for (let i = 0; i < drops.length; i++) {\r\n        // Случайный символ для текущей позиции\r\n        const text = getRandomChar();\r\n        \r\n        // Отрисовка символа\r\n        const x = i * fontSize;\r\n        const y = drops[i] * fontSize;\r\n        \r\n        // Первый символ в колонке делаем светлее для эффекта \"головы\" дождя\r\n        if (drops[i] >= 0) {\r\n          ctx.fillStyle = '#FFF'; // Белый цвет для \"головы\"\r\n          ctx.fillText(text, x, y);\r\n          ctx.fillStyle = '#0F0'; // Возвращаем зеленый для остальных символов\r\n        }\r\n        \r\n        // Смещаем символ вниз на следующей итерации\r\n        drops[i]++;\r\n        \r\n        // Если символ вышел за пределы экрана, создаем новую \"каплю\" с вероятностью\r\n        if (y > canvas.height && Math.random() > 0.975) {\r\n          drops[i] = Math.floor(Math.random() * -10); // Начинаем новую \"каплю\" над экраном\r\n        }\r\n      }\r\n    };\r\n\r\n    // Запускаем анимацию\r\n    const intervalId = setInterval(draw, 33); // ~30 fps\r\n\r\n    // Очистка при размонтировании компонента\r\n    return () => {\r\n      clearInterval(intervalId);\r\n      window.removeEventListener('resize', resizeCanvas);\r\n    };\r\n  }, []);\r\n\r\n  return <MatrixCanvas ref={canvasRef} style={{ opacity }} />;\r\n};\r\n\r\nexport default MatrixRain; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}